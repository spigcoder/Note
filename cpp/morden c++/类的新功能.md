# 类的新功能

默认成员函数

> 原来C++类中，有6个默认成员函数：
>
> 1. 构造函数
>
> 2. 析构函数
>
> 3. 拷贝构造函数
>
> 4. 拷贝赋值重载
>
> 5. 取地址重载
>
> 6. const 取地址重载 
>
>    
>
>    最后重要的是前4个，后两个用处不大。默认成员函数就是我们不写编译器会生成一个默认的。
>
> C++11 新增了两个：**移动构造函数和移动赋值运算符重载**。 针对移动构造函数和移动赋值运算符重载有一些需要注意的点如下： 如果你**没有自己实现移动构造函数，且没有实现析构函数 、拷贝构造、拷贝赋值重载中的任 意一个。这里是任意一个都没有实现，才会生成默认的，因为一般只有需要深拷贝的场景才需要析构，移动和拷贝赋值。所以如果实现了析构，就尽量把拷贝构造，拷贝赋值和移动构造和移动赋值都实现了** 那么编译器会自动生成一个默认移动构造。**默认生成的移动构造函数，对于内置类 型成员会执行逐成员按字节拷贝，自定义类型成员，则需要看这个成员是否实现移动构造， 如果实现了就调用移动构造，没有实现就调用拷贝构造。** 如果你没有自己实现移动赋值重载函数，且没有实现析构函数 、拷贝构造、拷贝赋值重载中 的任意一个，那么编译器会自动生成一个默认移动赋值。默认生成的移动构造函数，对于内 置类型成员会执行逐成员按字节拷贝，自定义类型成员，则需要看这个成员是否实现移动赋 值，如果实现了就调用移动赋值，没有实现就调用拷贝赋值。(默认移动赋值跟上面移动构造 完全类似)
>
> 如果你提供了移动构造或者移动赋值，编译器不会自动提供拷贝构造和拷贝赋值。

## 强制生成默认函数的关键字default

* C++11可以让你更好的控制要使用的默认函数。假设你要使用某个默认的函数，但是因为一些原 因这个函数没有默认生成。比如：我们提供了拷贝构造，就不会生成移动构造了，那么我们可以 使用default关键字显示指定移动构造生成。

```c++
class Person

{

public:
 Person(const char* name = "", int age = 0)
 :_name(name)
 , _age(age)
 {}
 Person(const Person& p)
 :_name(p._name)
 ,_age(p._age)
 {}
 Person(Person&& p) = default;

private:
 bit::string _name;
 int _age;
};

int main()
{
 Person s1;
 Person s2 = s1;
 Person s3 = std::move(s1);
 return 0;
}

```

## 禁止生成默认函数的delete

* 如果能想要限制某些默认函数的生成，在C++98中，是该函数设置成private，并且只声明补丁 已，这样只要其他人想要调用就会报错。在C++11中更简单，只需在该函数声明加上=delete即 可，该语法指示编译器不生成对应函数的默认版本，称=delete修饰的函数为删除函数。

```c++
class Person

{

public:
 Person(const char* name = "", int age = 0)
 :_name(name)
 , _age(age)
 {}
 Person(const Person& p) = delete;

private:
 bit::string _name;
 int _age;
};

int main()
{
 Person s1;
 Person s2 = s1;
 Person s3 = std::move(s1);
 return 0;
}
```

